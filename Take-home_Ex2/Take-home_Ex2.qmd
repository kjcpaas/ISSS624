---
title: "Take Home Exercise 2: A Case Study of Singapore Public Bus Commuter Flows"
author: "Kristine Joy Paas"
date: "6 Dec 2023"
date-modified: "last-modified"
format: html
execute: 
  echo: true
  eval: true
  warning: false
---

# Overview

The aim of this exercise to study the bus commuter flow patterns in Singapore to gain insights that support decision-making.

We will be examining the **weekend morning peak hours** (11 AM - 2 PM) to figure out where people go during weekends and holidays.

We will also be the modelling the spatial interaction between the different locations in Singapore, related to the bus commuter patterns.

Check <https://isss624-ay2023-24nov.netlify.app/take-home_ex02> for the full requirements of this exercise.

As this process is expected to have a lot of intermediate steps, **Save**, **Load**, and **Data clear** points are available to make our data wrangling more efficient.

::: callout-tip
### Save point

This is where data is written as `rds` files using `write_rds()` for important data sets that will be used in later analysis. Examples are:

-   Flow data, attractive and propulsive forces
-   Critical outputs of expensive calculations
-   Cleaned up data for lightweight processing
:::

::: callout-note
### Load point

This is where data is loaded from `rds` files using `read_rds()`. They were previously generated by the save point.

**TIP**: Skip to the load points to progress without running the code above it
:::

::: callout-warning
### Data clear point

This is where data that will not be used anymore are cleared. The data in RStudio environment will pile up and set `#| eval: false` in code chunks if you want skip the clearing. For example, the code below won't be run.

```{r}
#| eval: false
message <- "This code chunk executed"
```
:::

# Setup

```{r}
#| label: setup
pacman::p_load(sf, sp, tmap, tidyverse, knitr, sfdep, stplanr, reshape2)
tmap_mode("plot")
tmap_style("natural")
set.seed(1234)
```

# Data Wrangling

## Importing the Singapore subzone map

First, we will import the **Master Plan 2019 Subzone Boundary (Web)** data set that has been used in class. We will only keep the `SUBZONE_N` column and the geometry as we will only use this as the **base for our visualizations**.

```{r}
mpsz <- st_read(dsn = "data/geospatial",
                layer = "MPSZ-2019") %>%
  select(SUBZONE_N)
kable(head(mpsz))
```

::: {.callout-caution appearance="simple"}
### Correcting the projection

This data frame using the global GPS standard, [**WGS84**](https://gisgeography.com/wgs84-world-geodetic-system/). We need to convert this to [**SVY21**](https://app.sla.gov.sg/sirent/About/PlaneCoordinateSystem) projection that is more appropriate for Singapore ðŸ‡¸ðŸ‡¬ context.

```{r}
mpsz <- mpsz %>% st_transform(crs=3414)
```
:::

::: {.callout-tip collapse="true"}
### Save point

Let's save this geometry with corrected projection from plotting purposes.

```{r}
write_rds(mpsz, "data/rds/mpsz.rds")
```
:::

## Generating Hexagons for the Traffic Analysis Zone

To start our analysis, we will first build the honeycomb grid needed for our [traffic analysis zone (TAZ)](https://tmg.utoronto.ca/files/Reports/Traffic-Zone-Guidance_March-2021_Final.pdf). These hexagons must have a distance of **375m** from the center of the hexagon to the midpoint of each edge.

### Import Bus Stop Data

Next, we need to import the bus stop data as we will generate the honeycomb grid based on locations with bus stops.

```{r}
busstops <- st_read(dsn = "data/geospatial",
                    layer = "BusStop")
kable(head(busstops))
```

::: {.callout-caution collapse="true" appearance="simple"}
#### Correcting the projection

We want to use [SVY21](https://app.sla.gov.sg/sirent/About/PlaneCoordinateSystem) as the projection for this study as it is the projection used for local Singaporean context.

After the import, it shows that the **Projected CRS**is **SVY21**. However, checking the CRS with `st_crs()` tells a different story.

```{r}
st_crs(busstops)
```

As we can see EPSG value is **9001**, which correspond to [**WGS84**](https://gisgeography.com/wgs84-world-geodetic-system/). We have to fix the projection by transforming to EPSG value of **3414**, which corresponds to **SVY21**.

```{r}
busstops <- st_transform(busstops, crs = 3414)
```
:::

```{r}
#| code-fold: true
#| code-summary: "**Show the code**"
tm_shape(mpsz) +
  tm_polygons("lightgreen", title = "Singapore Boundary") +
  tm_layout(main.title = "Map of bus stops in Singapore",
            main.title.position = "center",
            main.title.size = 1.0,
            legend.height = 0.35, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_shape(busstops) +
  tm_dots(col = "red", size = 0.005, title = "Bus Stops") +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha = 0.2)
```

```{r}
busstops <- busstops %>% st_intersection(mpsz) %>% select(BUS_STOP_N, )
```

```{r}
#| code-fold: true
#| code-summary: "**Show the code**"
tmap_style("natural")
tm_shape(mpsz) +
  tm_polygons("lightgreen", title = "Singapore Boundary") +
  tm_layout(main.title = "Map of bus stops in Singapore",
            main.title.position = "center",
            main.title.size = 1.0,
            legend.height = 0.35, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_shape(busstops) +
  tm_dots(col = "red", size = 0.005, title = "Bus Stops") +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha = 0.2)
```

::: {.callout-important appearance="simple" collapse="true"}
#### Removing the bus stops outside Singapore

The map shows that there are bus stops in our data set that are outside Singapore bounds (green area). We can remove these points from our `busstops` data by using `st_intersection()`.

We will use this as `busstops` contains points, the intersection of the 2 geometries will generate points corresponding to the bus stops within Singapore.

We will also just retain the `BUS_STOP_N` to remove the columns we do not need.

```{r}
busstops <- busstops %>% st_intersection(mpsz) %>% select(BUS_STOP_N, )
```

Visualizing again, all the bus stops are now within Singapore.

```{r}
#| code-fold: true
#| code-summary: "**Show the code**"
tmap_style("natural")
tm_shape(mpsz) +
  tm_polygons("lightgreen", title = "Singapore Boundary") +
  tm_layout(main.title = "Map of bus stops in Singapore",
            main.title.position = "center",
            main.title.size = 1.0,
            legend.height = 0.35, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_shape(busstops) +
  tm_dots(col = "red", size = 0.005, title = "Bus Stops") +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha = 0.2)
```
:::

### Creating the honeycomb grid

Finally, we can generate the honeycomb grid using `st_make_grid()`, providing *cellsize* of **750m**.

::: {.callout-tip collapse="true" appearance="simple"}
#### Calculating cellsize

[Apothem](https://www.merriam-webster.com/dictionary/apothem) is defined as *the perpendicular from the center of a regular polygon to one of the sides**.***

The specification is this study requires hexagons to be **375 m** from the center of the hexagon to the center of one of it's edge.

![](images/apothem.png){fig-align="center"}

As such, this corresponds to the length of 2 opposite apothems, which is **750 m**.

The edge length is **not** the same as apothem. It is **433.013 m**m.

$$
375m/cos(30) = 433.013m
$$
:::

```{r}
honeycomb <- busstops %>% st_make_grid(cellsize = 750,
                                       what="polygons",
                                       square = FALSE) %>%
  st_sf() %>%
  mutate(NUM_BUS_STOPS = lengths(st_intersects(geometry, busstops))) %>%
  filter(NUM_BUS_STOPS > 0)
```

::: {.callout-tip collapse="true" appearance="simple"}
#### Code Explanation

st_make_grid()

:   Creates a grid that covers the entire bus stop geometry, including areas without bus stop.

st_sf()

:   Converts to simple feature data set

mutate()

:   Adds number of bus stops inside each hexagon

filter()

:   Removes hexagons without bus stops
:::

Let's plot the map to visually inspect if the hexagons cover all the bus stop locations.

```{r}
#| code-fold: true
#| code-summary: "**Show the code**"
tm_shape(mpsz) +
  tm_polygons("green", title = "Singapore Boundary", alpha = 0.5) +
  tm_shape(honeycomb) +
  tm_fill(col = "white", title = "Hexagons", alpha = 1) +
  tm_borders(alpha = 0.2) +
  tm_layout(main.title = "Honeycomb grid corresponding to Singapore bus stops",
            main.title.position = "center",
            main.title.size = 1.0,
            legend.height = 0.35, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_compass(type="8star", size = 2, bg.color = "white", bg.alpha = 0.5) +
  tm_scale_bar(bg.color = "white", bg.alpha = 0.5) +
  tm_shape(busstops) +
  tm_dots(col = "red", size = 0.001, title = "Bus Stops") +
  tm_grid(alpha = 0.2)
```

### Assigning id to each hexagon

Now that we have hexagons properly generated, we will assign id for each hexagon to be used as a unique identifier. We will store this id under the `HEX_ID` column, and can be used in joining data frames.

```{r}
honeycomb$HEX_ID <- sprintf("H%04d", seq_len(nrow(honeycomb))) %>% as.factor()
kable(head(honeycomb))
```

::: {.callout-tip collapse="true"}
### Save point

Let's save `honeycomb` as it contains the main geometry we will use in analysis.

```{r}
write_rds(mpsz, "data/rds/honeycomb_basic.rds")
```
:::

## Extracting hexagon-based bus commuter data

Next, we will extract the bus commuter data going from 1 hexagon to another.

### Importing the bus commuter data

We will use the *Passenger Volume By Origin Destination Bus Stops* from [LTA DataMall](https://datamall.lta.gov.sg/content/datamall/en.html) via API for the months of **October 2023**.

The data set is an aspatial data in `csv` format so we will use `read_csv()` to import the data.

```{r}
odbus <- read_csv("data/aspatial/origin_destination_bus_202310.csv")
kable(head(odbus))
```

::: {.callout-tip appearance="simple"}
If you want to use data for the other months, just find and replace `202310` to your desired month in `YYYYMM` format.
:::

### Filtering the relevant data

We only need the data for the **weekend morning peak period**, which is from 11 AM - 2 PM on weekends and holidays. As such, we will filter the data for the relevant hours.

We will also rename the `ORIGIN_PT_CODE` and `DESTINATION_PT_CODE` to be consistent with the naming with `busstops` as these columns can be associated to `busstops`'s `BUS_STOP_N`

::: {.callout-tip collapse="true" appearance="simple"}
#### How to filter data by *TIME_PER_HOUR*

The `TIME_PER_HOUR` in data set covers the data from the start to the end of the hour in **24-hour format**, i.e. when `TIME_PER_HOUR = 16`, this means bus taps from `4:00 PM` ton`4:59:59PM`.

Hence, if we want to get 6 to 9am data, we will filter by:

```         
TIME_PER_HOUR >= 6 & TIME_PER_HOUR < 9
```
:::

```{r}
od_trips <- odbus %>%
  filter( TIME_PER_HOUR >= 11 &
            TIME_PER_HOUR < 14 &
            DAY_TYPE == "WEEKENDS/HOLIDAY"
          ) %>%
  group_by(ORIGIN_PT_CODE, DESTINATION_PT_CODE) %>%
  summarise(TRIPS = sum(TOTAL_TRIPS)) %>%
  rename(
    ORIG_BUS_STOP_N = ORIGIN_PT_CODE,
    DEST_BUS_STOP_N = DESTINATION_PT_CODE
  )
kable(head(od_trips))
```

::: {.callout-warning collapse="true"}
#### Data clear point

We do not need `odbus` anymore as we already extracted the data relevant to our analysis.

```{r}
#| eval: true
rm(odbus)
```
:::

### Adding hexagon information to *od_trips* data

#### Generating lookup table for bus stop to associated hexagon

To connect the trip data to the their corresponding hexagon, we need to create a lookup table. This will serve as a glue in associating the aspatial `od_trips` data frame to the `honeycomb` data frame.

This can be done via `st_intersection()`.

```{r}
bs_hex <- st_intersection(busstops, honeycomb) %>%
  st_drop_geometry() %>%
  select(c(BUS_STOP_N, HEX_ID))
kable(head(bs_hex))
```

#### Joining *od_trips* and *bs_hex*

Next, we need to associate each origin bus stop and destination bus stop to their corresponding hexagons.

We can use that by doing `inner_join()` twice, once for the origin and another for the destination.

::: {.callout-tip collapse="true"}
##### Why *inner_join()* instead of *left_join()*?

We will use `inner_join` as there are `BUS_STOP_N` values in `od_trips` data that are not in `bs_hex`.

```{r}
c(
  od_trips$ORIG_BUS_STOP_N[!(od_trips$ORIG_BUS_STOP_N %in% bs_hex$BUS_STOP_N)],
  od_trips$DEST_BUS_STOP_N[!(od_trips$DEST_BUS_STOP_N %in% bs_hex$BUS_STOP_N)]
) %>% unique() %>% length()
```

There are **59** bus stops in `od_trips` that are not in `bs_hex`. **5** of these can be attributed the bus stops we removed due to them being out in Singapore. Others may be due to the *BusStops* data set not having complete information.

The proper way to handle this is to validate the existence of each of these bus stops and look at public sources (e.g. Google Maps, LTA data) and add coordinate data. However, as we do not have much to do this task, we have to **remove** these bus stops from our analysis as **we do not have geospatial data** to associate to the hexagons from the data sets available to us.

Therefore, we will use `inner_join` to keep only the observations in `trips` with the matching bus stops in `bs_hex`.
:::

::: panel-tabset
##### Origin

```{r}
od_trips <- od_trips %>%
  inner_join(bs_hex,
             by = c("ORIG_BUS_STOP_N" = "BUS_STOP_N")) %>%
  rename(ORIG_HEX_ID = HEX_ID)
```

##### Destination

```{r}
od_trips <- od_trips %>%
  inner_join(bs_hex,
             by = c("DEST_BUS_STOP_N" = "BUS_STOP_N")) %>%
  rename(DEST_HEX_ID = HEX_ID)
```
:::

#### Aggregating data by hexagon

Similar to [Filtering the relevant data], we will perform aggregations by `ORIG_HEX_ID` and `DEST_HEX_ID` to have an aggregated sum of trips by hexagon instead of bus stops.

```{r}
od_hex <- od_trips %>%
  group_by(ORIG_HEX_ID, DEST_HEX_ID) %>%
  summarise(TRIPS = sum(TRIPS))
kable(head(od_hex))
```

::: {.callout-tip collapse="true"}
#### Save point

Let's save `od_trips` as it contains the data needed to visualize flow data. Take note that this **includes intra-zonal trips**.

```{r}
write_rds(od_trips, "data/rds/od_trips202310.rds")
```
:::

::: {.callout-warning collapse="true"}
#### Data clear point

We do not need `busstops`, `bs_hex`, `od_trips` anymore as we already have the necessary data for doing hexagon-based analysis in `od_hex`.

```{r}
#| eval: true
rm(busstops)
rm(bs_hex)
rm(od_trips)
```
:::
